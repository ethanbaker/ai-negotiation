# -*- coding: utf-8 -*-
"""Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gJuOXcejO7uRnHftPkaoTBsiKezNd_Tl

# Evaluating Human versus AI Efficiency in Negotiations

## Code Implementation

*Sometimes there's an issue where '_ctypes' is not available in the Python environment. This can be resolved by adding a try-except block to check if the module is available before importing it. If you're encountering an issue with '_ctypes' refer to the corresponding README.md section.*
"""

try:
    import _ctypes
except ModuleNotFoundError:
    raise ModuleNotFoundError("The _ctypes module is not available. Please refer to the README.md for more information.")

"""*In order for this project to work, you need to have an OpenAI key for GPT API access. You can set your OpenAI API key here*"""

OPENAI_KEY = ""  # Add your OpenAI API key here

"""### Installation

Perform necessary imports. We first install external libraries (`negmas` for negotiation, `openai` for a large learning model to be used as a negotiating agent). Next, we can install the required classes, functions, and types used to continue the project.
"""

#!pip install negmas
#!pip install openai

from time import sleep
import json
import sys

from negmas.sao import SAONegotiator, SAOState
from negmas.outcomes import Outcome
from negmas.gb import ResponseType
from negmas import make_issue, SAOMechanism
from negmas.preferences import LinearAdditiveUtilityFunction as LUFun
from negmas.preferences.value_fun import IdentityFun, LinearFun
from openai import OpenAI
import matplotlib.pyplot as plt

"""### Definiting the Negotiation

Here we create a list of issues the negotiation will focus on. Simple negotiations, such as negotiations about a single price, can become so abstracted that the complex natural language has no effect on the outcome. For example, a human buyer could intrinsically value an item at $10 and will therefore never buy the item at above \$10, thereby either obtaining the item for \$10 or less or ending the negotiation. In order to reduce this mindset, we use three issues in our negotiation: price, quantity, and delivery time. As explained below in the natural language prompts, different negotiating agents value these issues differently.

Each issue has a name and the associated value range `negmas` will use for that issue. For price, negotiators have a range of \$1 to \$30. For quantity, negotiatiors have a range of 1 to 10 items. For delivery time, negotiators have a range of 0 to 10 units of time.
"""

ISSUES = ["price", "quantity", "delivery_time"]
ISSUE_VALUES = [(1, 31), (1, 11), (0, 11)]

"""Here we create prompts to inform negotiators about their goal for the negotiation. We inform our negotiators of the three specified issues that they will negotiate over (price, quantity, and delivery time). The buyer and seller have no extra information than their initial prompt and the offers of the other negotiator. The main goals of the negotiators depend on their roles and are summarized as follows:

**Buyer**:
* Wants the lowest price possible
* Wants the highest quantity possible
* Wants a quick delivery time
* Values lower price above other issues

**Seller**:
* Wants the highest price possible
* Wants the highest quanity possible
* Is relatively indifferent about delivery time
* Values higher price above other issues

In setting up the simulation in this way, we create multiple dynamics that affects the negotiators. The buyer and seller are primarily negotiating about the price of the good being sold. Both buyers and sellers would ideally want a high level of quantity at their preferred price, but this value may fluctuate depending on how the negotiation goes. In addition, the delivery time represents a situation where one agent prefers an outcome while the other agent prefers no set outcome. This is intended to hopefully give the seller a way to force the buyer into a settlement by applying "concessions" to the delivery time field. Our team will study this effect by analyzing our results.
"""

BUYER_PROMPT = """You are a buyer agent representing a company that needs to purchase a specific item from a seller. You need to negotiate the purchase based on three key issues:

1. Price: The lower the price, the better it is for your company. Your goal is to secure the best possible deal without exceeding your budget

2. Quantity: You have a target quantity that you want to purchase. While securing a good price is important, you also want to make sure you get enough quantity to meet your company's needs

3. Delivery Time: Your company prefers quicker delivery to ensure that the items are available for immediate use. However, depending on the price and quantity, you may be willing to compromise slightly on delivery time if it leads to a better overall deal

Your task is to negotiate with a seller agent to achieve the best possible outcome for your company across these three issues. Aim to balance your needs across price, quantity, and delivery time to reach an agreement that maximizes your overall satisfaction. Keep in mind that the seller may have different priorities, such as selling at a higher price or offloading more quantity

You have 20 negotiation steps to reach an agreement with the seller agent. If you don't reach an agreement in this time, then the negotiation is considered unsuccessful

Remember:
- Prioritize getting a low price and securing the required quantity
- Be flexible with delivery time if it helps you secure better terms on price or quantity"""

SELLER_PROMPT = """You are a seller agent representing a company that wants to sell its items to a buyer. You need to negotiate the sale based on three key issues:

1. Price: Your goal is to sell the items at the highest price possible to maximize revenue. However, you may need to consider offering a lower price if it helps you close the deal or increase the quantity sold

2. Quantity: You prefer to sell a larger quantity of items in this deal, as it helps reduce inventory and increase sales volume. You may be willing to adjust the price slightly if the buyer agrees to purchase a larger quantity

3. Delivery Time: You are relatively indifferent to the delivery time, but you should consider it as a possible bargaining chip. If the buyer insists on quicker delivery, you might negotiate other aspects, such as price or quantity, in exchange for accommodating their preferred delivery time

Your task is to negotiate with the buyer agent to achieve the best possible outcome for your company across these three issues. Aim to reach an agreement that maximizes your overall revenue while addressing the buyer's needs. Be prepared to make trade-offs between price, quantity, and delivery time to find a mutually acceptable deal

You have 20 negotiation steps to reach an agreement with the buyer agent. If you don't reach an agreement in this time, then the negotiation is considered unsuccessful.

Remember:
- Prioritize selling at a high price and maximizing the quantity sold
- Use delivery time as a negotiable aspect if it helps you secure better terms on price or quantity"""

"""Here we make a list of functions that will be used by the AI negotiator to make decisions. These functions are used to make sure the language model is able to make consistent decisions that follow a specification as described below. Because AI models can return output in different forms (for example, "I reject this offer" is equivalent to "I do not accept this offer"), we force the AI model to respond in set manners, such as only saying "yes" or "no," guaranteeing we can accurately conduct the simulation."""

AI_NEGOTIATOR_TOOLS = [
    {
        "type": "function",
        "function": {
            "name": "respond",
            "description": "Respond to a negotiation proposal by choosing to accept or deny an outcome. Call this whenever the user makes a proposal and asks for your response",
            "parameters": {
                "type": "object",
                "properties": {
                    "decision": {
                        "type": "string",
                        "enum": ["yes", "no"],
                        "description": "The decision to accept or deny the outcome"
                    },
                },
            },
            "required": ["decision"],
            "additionalProperties": False,
        }
    },
    {
        "type": "function",
        "function": {
            "name": "propose",
            "description": "Propose an outcome for the negotiation. Call this whenever the user asks for you to make a proposal on the given negotiation items",
            "parameters": {
                "type": "object",
                "properties": {
                    "price": {
                        "type": "integer",
                        "description": "The ideal cost of the item in the negotiation",
                    },
                    "quantity": {
                        "type": "integer",
                        "description": "How many units of the item should be traded in the negotiation",
                    },
                    "delivery_time": {
                        "type": "integer",
                        "description": "How long it should take for the item to be delivered in the negotiation",
                    },
                },
                "required": ["price", "quantity", "delivery_time"],
                "additionalProperties": False,
            },
        }
    }
]

"""### Negotiators

The `HumanNegotiator` class defers all negotiation descisions a human that can interact via the command line. Information about the current negotiation state is displayed to the user, at which point the user is prompted to make a decision.
"""

class HumanNegotiator(SAONegotiator):
    def __init__(self, name: str, role: str):
        """
        Basic constructor for the HumanNegotiator class.

        :param name: The name of the negotiator to pass to the superclass' constructor.
        :param role: The role of this negotiator.
        """
        super().__init__(name)
        self.round = 1
        self.name = name

        # Set roles/opposing roles for the negotiator
        self.role = role
        self.opposing_role = "buyer" if role == "seller" else "seller"

        # Print the prompt to the user depending on their role
        print("\033[ \033[J\n")
        print([BUYER_PROMPT, SELLER_PROMPT][1 if role == "seller" else 0])

        sleep(5)

        input("\nPress enter to continue when ready")


    def respond(self, state: SAOState, source: str = "") -> ResponseType:
        """
        This method is called when the other negotiator has proposed an outcome.

        :param state: The current state of the negotiation.
        :param source: Ignored
        :return: The outcome that the negotiator chooses to propose.
        """
        self.round += 1

        # Clear the screen
        print("\033[ \033[J\n")
        print(f"Agent: {self.name}\n")

        if self.round == 1:
          print(f"The {self.opposing_role} denied your proposed outcome.\n")

        print(f"It is your turn to accept or deny an outcome as the {self.role}.\n")

        # Reject empty offers automatically
        offer = state.current_offer
        if offer is None:
            return ResponseType.REJECT_OFFER

        # Print the proposed outcome to the user
        print(f"The {self.opposing_role} has been proposed the following outcome:")
        for i in range(len(ISSUES)):
            print(f"  {ISSUES[i]}: {offer[i]}")

        # Ask the user if they accept or reject the offer
        print("\nDo you accept this outcome? (y/n)")
        response = input().lower()

        # Accept the offer if the user agrees
        if response == "y":
            return ResponseType.ACCEPT_OFFER

        # Reject the offer if the user disagrees
        return ResponseType.REJECT_OFFER


    def propose(self, state: SAOState) -> Outcome:
        """
        This method is called when it is the negotiator's turn to propose an outcome.

        :param state: The current state of the negotiation.
        :return: The outcome that the negotiator chooses to propose.
        """
        # Clear the screen
        print("\033[ \033[J\n")
        print(f"Agent: {self.name}\n")
        print(f"It is your turn to propose an outcome as the {self.role}.")
        print(f"It is round {self.round} of the negotiation.\n")

        if state.current_offer is not None:
            # Print the current state of the negotiation to the user if an offer has been made
            print("The current state of the negotiation is as follows:")
            for i in range(len(ISSUES)):
                print(f"  {ISSUES[i]}: {state.current_offer[i]}")

        else:
            # Otherwise, inform the user that it is the first proposal
            print("This is the first proposal of the negotiation. Enter your proposed outcome below.")

        # Prompt the user to enter a value for each issue
        proposed_outcome: tuple[int] = ()
        i = 0
        while i < len(ISSUES):
            upper_lim = ISSUE_VALUES[i][1] - 1
            lower_lim = ISSUE_VALUES[i][0]

            # Ask the user for their input
            print(f"\nEnter a value for {ISSUES[i]} (range = [{lower_lim}, {upper_lim}]): ", end="")

            # Parse the user's input and add it to the decision
            try:
                val = int(input())

                # Validate the output
                if val < lower_lim or val > upper_lim:
                    print(f"Invalid input. Please enter a value between {lower_lim} and {upper_lim}.")
                    continue

                # Output is valid, so add it to the outcome and continue
                proposed_outcome += (val,)
                i += 1
            except ValueError:
                # Catch bad input and prompt the user to try again
                print("Invalid input. Please enter an integer value.")

        return proposed_outcome

"""The `AINegotiator` defers descisions to an external AI model. Information about the current negotiation state is encoded into a prompt, which is then passed to a large language model as a tool call. The output of this tool call is used to inform the negotiator's decisions."""

class AINegotiator(SAONegotiator):
    # Limit of how many recursive calls to the AI model can be made
    MAX_MODEL_CALL_DEPTH = 5

    def __init__(self, name: str, role: str, client: OpenAI, logging=False):
        """
        Basic constructor for the HumanNegotiator class.

        :param name: The name of the negotiator to pass to the superclass' constructor.
        :param role: The role of this negotiator.
        :param client: The OpenAI client to use for the AI model.
        """
        super().__init__(name)
        self.name = name
        self.logging = logging

        # Previous proposed outcome
        previous_outcome = (-1, -1, -1)

        # Set self and opposing roles
        self.role = role
        self.opposing_role = "buyer" if role == "seller" else "seller"

        # Initialize the messages in the conversation to the initial buyer/seller prompt
        self.messages = []
        self.messages.append({
            "role": "system",
            "content": [BUYER_PROMPT, SELLER_PROMPT][1 if role == "seller" else 0].replace("\n", " "),
        })

        # Initialize the OpenAI client
        self.client = client

        if self.logging:
            print(f"Initialized AINegotiator '{name}' as the {role}")
            print("Messages:", '\n'.join([str(v) for v in self.messages]))


    def send_message_to_model(self, messages):
        """
        This method sends a list of messages to the AI model for processing.

        :param messages: A list of messages to send to the AI model.
        """
        if self.logging:
            print("\n\nSending messages:\n", '\n  '.join([str(v) for v in self.messages]))
            print("\n\n")

        # Send our messages to the AI model
        response = self.client.chat.completions.create(
            model = "gpt-3.5-turbo",
            messages = messages,
            tools = AI_NEGOTIATOR_TOOLS,
        )

        if self.logging:
            print(f"Received response: {response}")
            print("\n\n")

        return response


    def respond(self, state: SAOState, source: str = "") -> ResponseType:
        """
        This method is called when the other negotiator has proposed an outcome.

        :param state: The current state of the negotiation.
        :param source: Ignored
        :return: The outcome that the negotiator chooses to propose.
        """
        if self.logging:
            input("Press enter to continue to next step")

            print("\033[ \033[J\n")
            print(f"Agent: {self.name}")
            print("Model is responding to current negotiation state")

        # Initialize the message
        message = f"I am the {self.opposing_role}. "

        # Reject empty offers automatically
        offer = state.current_offer
        if offer is None:
            return ResponseType.REJECT_OFFER

        # Add the proposed outcome to the message
        message += f"I propose the following outcome for the negotiation: "
        message += ", ".join([f"{ISSUES[i]}: {offer[i]}" for i in range(len(ISSUES))])

        # Ask the user if they accept or reject the offer
        message += ". Do you accept this outcome? Respond using the 'respond' tool call"

        # Add the message to the conversation
        self.messages.append({
            "role": "user",
            "content": message,
        })

        # Respond with the model
        self.model_call_depth = 0
        return self.respond_with_model(state, source)


    def respond_with_model(self, state: SAOState, source: str = "") -> ResponseType:
        """
        Helper method used to get multiple responses from the AI model in
        case of an invalid response.

        :param state: The current state of the negotiation.
        :param source: Ignored
        :return: The outcome that the negotiator chooses to propose.
        """
        self.model_call_depth += 1
        if self.model_call_depth >= self.MAX_MODEL_CALL_DEPTH:
            if self.logging:
                print(f"Model call depth exceeded, returning default response")

            return ResponseType.REJECT_OFFER

        # Send the message to the AI model
        response = self.send_message_to_model(self.messages)
        response_message = response.choices[0].message

        # Ignore any message that isn't a tool call
        if dict(response_message).get("tool_calls") == None or len(dict(response_message).get("tool_calls")) == 0:
            if self.logging:
                print(f"Model response is not a tool call, retrying")

            return self.respond_with_model(state, source)

        tool_calls = dict(response_message).get("tool_calls")

        # Find the tool called
        tool_called = dict(dict(tool_calls[0]).get("function")).get("name")

        if self.logging:
            print(f"Found tool called by model: '{tool_called}'")

        # The model should be responding, so try again if the tool is not the 'respond' tool
        if tool_called != "respond":
            if self.logging:
                print("Model function call is not 'respond', retrying")

            return self.respond_with_model(state, source)

        # Parse the function arguments
        args = json.loads(dict(dict(tool_calls[0]).get("function")).get("arguments"))
        decision = args.get("decision")

        if self.logging:
            print(f"Model made decision: '{decision}'")

        if decision == "yes":
            self.messages.append({
                "role": "assistant",
                "content": "Yes",
            })

            if self.logging:
                print("Model accepted offer")
            return ResponseType.ACCEPT_OFFER

        elif decision == "no":
            self.messages.append({
                "role": "assistant",
                "content": "No",
            })

            if self.logging:
                print("Model denied offer")
            return ResponseType.REJECT_OFFER

        else:
            if self.logging:
                print("Model made invalid decision, retrying")
            return self.respond_with_model(state, source)


    def propose(self, state: SAOState) -> Outcome:
        """
        This method is called when it is the negotiator's turn to propose an outcome.

        :param state: The current state of the negotiation.
        :return: The outcome that the negotiator chooses to propose.
        """
        if self.logging:
            input("Press enter to continue to next step")

            print("\033[ \033[\n")
            print(f"Agent: {self.name}\n")
            print("Model is proposing new negotiation state")

        # Initialize the message
        message = f"Since you did not accept my offer, create your own offer and show it to me. "

        if state.current_offer is not None:
            # Add the current state of the negotiation to the message
            message += "The current state of the negotiation is as follows: "
            message += ", ".join([f"{ISSUES[i]} = {state.current_offer[i]}" for i in range(len(ISSUES))])
            message += ". "

        else:
            # Otherwise, inform the agent that it is the first proposal
            message = "This is the first proposal of the negotiation. "

        # Prompt the user to enter a value for each issue
        for i in range(len(ISSUES)):
            upper_lim = ISSUE_VALUES[i][1] - 1
            lower_lim = ISSUE_VALUES[i][0]

            # Ask the user for their input
            message += f" Enter a value for {ISSUES[i]} (range = [{lower_lim}, {upper_lim}])."

        message += " Propose your outcome by using the 'propose' tool call"

        # Add the message to the conversation
        self.messages.append({
            "role": "user",
            "content": message,
        })

        # Respond with the model
        self.model_call_depth = 0
        return self.propose_with_model(state)


    def propose_with_model(self, state: SAOState) -> Outcome:
        """
        Helper method used to get multiple responses from the AI model in
        case of an invalid response.

        :param state: The current state of the negotiation.
        :return: The outcome that the negotiator chooses to propose.
        """
        self.model_call_depth += 1
        if self.model_call_depth >= self.MAX_MODEL_CALL_DEPTH:
            if self.logging:
                print(f"Model call depth exceeded, returning default response")

            return self.previous_outcome

        # Send the message to the AI model
        response = self.send_message_to_model(self.messages)
        response_message = response.choices[0].message

        # Ignore any message that isn't a tool call
        if response_message != None:
            pass

        elif dict(response_message).get("tool_calls") == None or len(dict(response_message).get("tool_calls")) == 0:
            if self.logging:
                print(f"Model response is not a tool call, retrying")

            return self.propose_with_model(state, state)

        tool_calls = dict(response_message).get("tool_calls")

        # Find the tool called
        tool_called = dict(dict(tool_calls[0]).get("function")).get("name")

        if self.logging:
            print(f"Found tool called by model: '{tool_called}'")

        # The model should be responding, so try again if the tool is not the 'propose' tool
        if tool_called != "propose":
            if self.logging:
                print("Model function call is not 'propose', retrying")

            return self.propose_with_model(state, state)

        # Parse the function arguments
        args = json.loads(dict(dict(tool_calls[0]).get("function")).get("arguments"))

        price, quantity, delivery_time = None, None, None
        try:
            price = int(args.get("price"))
            quantity = int(args.get("quantity"))
            delivery_time = int(args.get("delivery_time"))
        except ValueError:
            if self.logging:
                print(f"Model arguments are invalid (price: {price}, quantity: {quantity}, delivery_time: {delivery_time}), retrying")

            return self.propose_with_model(state)

        self.messages.append({
            "role": "assistant",
            "content": f"My proposed outcome is as follows. Price: {price}, Quantity: {quantity}, Delivery Time: {delivery_time}",
        })

        if self.logging:
            print(f"Model proposed outcome: (price: {price}, quantity: {quantity}, delivery_time: {delivery_time})")

        self.previous_outcome = (price, quantity, delivery_time)
        return (price, quantity, delivery_time)

"""### Negotiation Setup

Here we create the setup for the negotiation. We create the list of issues our agents will negotiate over, and we define the total number of iterations in the negotiation to be 20 steps. Then, we define a utility function that sums all issues together to give a basic representation on how the agent is performing, which can be graphed to provide a summary of the negotiation when complete.

*Note that this method needs to be re-initialized every time a simulation is run.*
"""

# Create an OpenAI client
client = OpenAI(
  api_key=OPENAI_KEY,
)


# Define the issues that will be negotiated over
issues = []
for i in range(len(ISSUES)):
    issues.append(make_issue(name=ISSUES[i], values=ISSUE_VALUES[i]))


# Create a negotiation session using the SAOMechanism class. The negotiation
# is limited to 20 steps.
session = SAOMechanism(issues=issues, n_steps=20)


# Create a basic utility function for buyers
ufun_buyer = LUFun(
    values={
        "price": LinearFun(-1),
        "quantity": LinearFun(1),
        "delivery_time": LinearFun(-1),
    },
    outcome_space=session.outcome_space,
)

# Create a basic utility function for sellers
ufun_seller = LUFun(
    values={
        "price": LinearFun(1),
        "quantity": LinearFun(1),
        "delivery_time": LinearFun(0),
    },
    outcome_space=session.outcome_space,
)

"""### Running the Negotiation

Here we run the negotiation by creating two agents as specified.
"""

# Google Colab Testing

agent_types = ["human", "ai"] # Define what agent types will be run in this negotiation
starter_role = "buyer"        # Define which role starts the negotiation

# Add the agents to the negotiation session
role_check = 1 if starter_role == "seller" else 0
for i in range(len(agent_types)):
    role = "buyer" if i == role_check else "seller"
    ufun = ufun_buyer if i == role_check else ufun_seller

    if agent_types[i] == "human":
        session.add(HumanNegotiator(name=f"Human Agent {i + 1}", role=role), preferences=ufun)
    elif agent_types[i] == "ai":
        session.add(AINegotiator(name=f"AI Agent {i + 1}", role=role, client=client, logging=False), preferences=ufun)
    else:
        raise ValueError(f"Invalid agent type: {agent_types[i]}")

# Run the negotiation session
results = session.run()

# Print the results of the negotiation
print("\nNegotiation Results:", results)
print("\nFinal Agreement:", results.agreement)

# Print negotiation steps
roles = ['buyer', 'seller'] if starter_role == "buyer" else ['seller', 'buyer']
for i in range(len(session.extended_trace)):
    print(f"Step {i + 1}:")
    print(f"  Agent {(i % 2) + 1} ({agent_types[(i % 2)]} - {roles[0 if i % 2 == 0 else 1]}) proposed action {session.extended_trace[i][2]}")
    print(f"  Agent {(i % 2) + 2} {['accepted', 'denied'][0 if i == len(session.extended_trace) - 1 else 1]} offer")

print()

session.plot(show_reserved=False)
plt.show()

"""Code for a command line implementation. This is currently unused, as our team did not add support for graphing in the command line.

# Command Line Code
if __name__ == "__main__":
    # Check if the correct number of command line arguments are provided
    if len(sys.argv) != 4:
        print("Usage: python runner.py <agent1_type> <agent2_type> <starter_role>")
        exit(1)

    # Parse command line arguments to determine which matchup will be present
    agent_types = sys.argv[1:3]
    starter_role = sys.argv[3]

    # Add the agents to the negotiation session
    role_check = 1 if starter_role == "seller" else 0
    for i in range(len(agent_types)):
        role = "buyer" if i == role_check else "seller"
        ufun = ufun_buyer if i == role_check else ufun_seller

        if agent_types[i] == "human":
            session.add(HumanNegotiator(name=f"Human Agent {i + 1}", role=role), preferences=ufun)
        elif agent_types[i] == "ai":
            session.add(AINegotiator(name=f"AI Agent {i + 1}", role=role, client=client, logging=False), preferences=ufun)
        else:
            raise ValueError(f"Invalid agent type: {agent_types[i]}")

    # Run the negotiation session
    results = session.run()

    # Print the results of the negotiation
    print("\nNegotiation Results:", results)
    print("\nFinal Agreement:", results.agreement)

    # Print negotiation steps
    roles = ['buyer', 'seller'] if starter_role == "buyer" else ['seller', 'buyer']
    for i in range(len(session.extended_trace)):
        print(f"Step {i + 1}:")
        print(f"  Agent {(i % 2) + 1} ({agent_types[(i % 2)]} - {roles[0 if i % 2 == 0 else 1]}) proposed action {session.extended_trace[i][2]}")
        print(f"  Agent {(i % 2) + 2} {['accepted', 'denied'][0 if i == len(session.extended_trace) - 1 else 1]} offer")

    print()
"""